# [C] 함수 포인터

<br><br>

# 함수 포인터

힘수의 첫 번째 명령문이 함수의 시작 주소이며, 그 함수의 주소를 가리키는 포인터로, 함수 포인터를 사용해서 해당 함수를 호출하여 실행할 수 있다. 함수 원형이 같은 함수들을 묶어서 배열로 사용하면 하나의 함수 포인터로 여러개의 함수를 사용할 수 있다.

<br><br>

### **함수 포인터 선언하기**

함수 포인터는 함수 원형을 사용해서 포인터를 선언하고, & 연산자를 사용하여 함수를 대입하여 함수의 주소를 저장한다.

- 일반 함수 포인터 선언하기 : *자료형* (**변수이름*)(*매개변수의자료형1*, *매개변수의자료형2*, *…*); = &*함수이름*;
- 배열 함수 포인터 선언하기 : *자료형* (**변수이름*[*요소개수*])(*매개변수의자료형1*, *매개변수의자료형2*, …) = {&*함수이름*, &*함수이름*, &*함수이름*, *…*};

ex) int Func(int a, int b); //함수 선언

int (*fp)(int, int) = &Func; //함수포인터를 Func() 함수로 초기화

int nResult = (*fp)(2, 3); //함수포인터로 Func() 함수 사용

<br><br>

ex) int Sum(int, int);

int Sub(int, int);

int Mul(int, int);

int Div(int, int);

int (*p[4])(int)(int) = {&Sum, &Sub, &Mul, &Div};

int fResult[4] ;

for(int i = 0; i < 4; ++i)

fResult[i] = (*p[4])(15, 23);

<br><br>

>[!note]
> **함수 포인터 자료형 만들기**
> 
> typedef 키워드를 이용하여 함수 포인터 자료형을 만들면 함수포인터 선언을 간단하게 만들 수 있다.
> 
> ex) typedef int (*FP_TYPE)(int, int);
> 
> FP_TYPE p[4] = {&Sum, &Sub, &Mul, &Div}; //int (*p[4])(int, int);

<br><br>
<br><br>

---

# 콜백 함수

자신이 사용할 함수가 명시적으로 호출되지 않고 함수 포인터에 의해 암시적으로 호출되는 방식을 콜백(Callback)이라고 한다. 

예를 들어, 라이브러리 프로그래머는 코드가 노출되면 안 되기 때문에 해당 코드를 컴파일해서 라이브러리(library, *.lib)형식의 파일로 제공한다. 그리고 라이브러리 안에 있는 함수들의 함수 원형을 알아야 사용자들도 사용할 수 있기 때문에 함수 원형들을 헤더 파일(header, *.h)에 넣어서 함께 제공한다.

이때, 라이브러리 프로그래머는 예측한 내용을 모두 함수에 반영하다 보면 조건문이 많아져서 해당 함수는 비효율적인 함수가 될 수밖에 없다. 그래서 필요한 기능만 함수에 구현하고 나머지 예상되는 조건은 함수 포인터를 사용하여 사용자가 직접 함수를 구현하고 라이브러리 함수에서 호출할 수 있도록 하는 방식이 바로 콜백 구조이다. 운영체제는 한번 만들며 10년 이상 사용하게 되는데 10년 뒤 추가될 기술을 예측한다는 것은 불가능에 가깝기 때문에 콜백 함수를 많이 사용한다.

<br><br>

### **함수를 함수의 매개변수 인수로 전달하기**

다른 함수의 매개변수의 인수로 전달할 수 있는 함수의 서명은 함수 매개변수의 명세로 결정된다.

함수의 매개변수 명세는 함수 인수의 성격에 따라 정해지며, 다른 함수에 함수를 인수로 넘기는 방법은 함수 포인터(함수 이름을 인수 값으로 사용), 함수자, 람다식 세가지가 있다.
