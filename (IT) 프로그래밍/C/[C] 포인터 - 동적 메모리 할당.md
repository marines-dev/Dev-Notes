# [C] 포인터 : 동적 메모리 할당

<br><br>

## 프로세스(Process)

프로세스를 '실행 중인 프로그램'이라고도 하며, 운영체제가 실행 파일의 명령을 읽어서 메모리 재구성(프로세스)하면, CPU는 프로세스에 저장된 명령을 실행한다. 이러한 프로세스는 세그먼트의 집합으로 구성되어 있다.

<br><br>
<br><br>

**세그먼트(Segment)**

- 코드 세그먼트 (Code Segment) : 소스를 기계어로 번역한 실행 파일이 실행되고, 프로세스가 만들어지면 기계어 명령을 저장하여 프로그램 실행에 사용된다.
- 데이터 세그먼트(Data Segment) : 프로그램이 시작해서 끝날 때까지 사용되는 데이터를 저장한다. 데이터 세그먼트의 데이터는 컴파일할 때 정해지며 전역 변수, static 변수, 문자열 상수가 저장된다.
- 스택 세그먼트(Stack Segment) : 프로그램 실행 중에 필요한 임시 데이터를 저장하는 영역으로 스택(Stack), 힙(Heep) 공간으로 나뉜다. 스택에는 함수가 호출될 때 함수 안에 선언된 지역 변수가 저장되고, 힙에는 동적 메모리가 저장된다.

<br><br>
<br><br>

## 메모리 할당

**정적 메모리 할당**

컴파일할 때 데이터 세그먼트, 스택 세그먼트에 변수를 저장할 메모리 위치를 정하기 때문에 프로그램이 실행되는 중간에 크기를 변경할 수 없다. 정적 할당된 메모리의 크기를 변경하려면 코드를 변경한 후 다시 컴파일해야 한다. 스택에 기본적으로 저장되는 메모리 크기는 최대 1Mbyte이다. 그런데 스택의 실제 크기는 프로그램이 실행될 때가 돼서야 알 수 있기 때문에 컴파일한 프로그램이 스택을 얼마나 사용할지 예상할 수 없기 때문에 메모리의 크기가 1Mbyte를 넘게 선언해도 컴파일 오류가 처리되지 않고 프로그램을 실행할 때 실행 오류가 발생하게 된다. 그러나 프로그램에서 사용하는 데이터는 보통 1Myte보다 훨씬 큰 경우가 많다. 

<br><br>

>[!note]
> **정적 할당 메모리 관리 방법**
>
> 전역 변수는 프로그램이 시작해서 끝날 때까지 할당된 메모리 크기나 주소가 바뀌지 않기 때문에 어디에 할당되었는지에 대한 추가 정보가 필요없다. 그러나 지역 변수는 함수 호출에 따라 메모리 할당과 해제가 반복되기 때문에 변수 주소가 계속 바뀐다. 그러나 지역 변수의 개수만큼 메모리가 추가된다면 메모리 낭비가 심해진다. 같은 함수에 안에 선언된 변수는 순차적으로 메모리에 할당되기 때문에 컴파일하는 시점에서 함수 하나에 몇 개의 지역 변수가 선언되어 있는지 순차적으로 저장되어 메모리 그룹으로 관리할 수 있다. 그래서 지역 변수의 개수에 상관없이 함수의 START 포인터와 END 포인터를 사용해 관리할 수 있다. START 포인터의 주소 연산으로만 지역 변수의 메모리 그룹을 관리할 수 있지만 END포인터가 필요한 이유는 함수 안에서 다른 함수를 호출하면 다른 함수 안에 선언된 변수는 END포인터 이후의 메모리 공간에 놓이기 때문에 END포인터는 다음에 호출될 함수의 메모리 시작 위치를 결정한다.

<br><br>

>[!note]
> **스택(Stack)**
> 
> 스택은 두 개의 포인터로 많은 양의 데이터를 효과적으로 관리하는 자료구조로, 프로세스 영역에서 스택은 베이스 포인터(BP, Base Pointer)를 기준으로 데이터가 추가될 때마다 순서대로 쌓아 올리는 구조이며 새로운 데이터가 추가될 위치는 스택 포인터(SP, Stack Pointer)가 가리키게 된다. 그러므로 베이스 포인터가 START 포인터, 스택 포인터가 END 포인터이다. 스택 세그먼트의 스택은 지역 변수를 스택 자료구조로 메모리를 관리할 수 있으며 PUSH하여 데이터를 추가하면 스택 포인터가 가리키는 메모리 주소에 저장되고 4byte(32비트 운영체제 기준)만큼 증가하며, POP하여 스택 포인터 주소가 4byte 만큼 감소한다. 그러나 실제 동작은 PUSH는 스택 포인터에 저장된 주소가 감소하고, POP은 스택 포인터의 주소를 증가시킨다. 왜냐하면 지역 변수가 늘어날 수록 PUSH와 POP 코드가 많아져 프로그램 효율이 떨어지기 때문에 스택 포인터에 저장된 주소는 PUSH와 POP 명령을 사용하지 않고 SUB 명령으로 포인터 값에서 할당 크기만큼 빼서 공간을증가하고, ADD 명령으로 포인터 값에서 할당 크기만큼 증가시켜 공간을 제거하기 때문이다.

<br><br>

>[!note]
> **스택 프레임(Stack Frame)**
> 
> 함수를 호출할 때 일어나는 스택의 변화인 스택 프레임은 컴파일할 때 결정되기 때문에 정적 메모리 할당이다. 그러므로 지역 변수를 추가하거나 배열 크기를 변경하려면 스택 프레임이 수정되어야 하기 때문에 코드를 수정하고 다시 컴파일해야 한다. 그리고 배열을 선언할 때 []안에 반드시 상수를 적어야 하는 이유도 변수가 오면 정적으로 할당할 크기를 고정할 수 없어서(스택 포인터 연산을 결정할 수 없어서)스택 프레임을 구성할 수 없기 때문이다.

<br><br>

**동적 메모리 할당**

프로세스의 기본적인 스택 메모리만으로는 공간이 부족하기 때문에 더 큰 메모리를 사용할 방법이 필요하다. 이러한 정적 메모리 할당의 한계를 해결하기 위해 힙(Heap)이라는 동적 메모리 할당 공간을 제공한다. 힙은 프로그램 실행 중에 원하는 시점에 원하는 크기만큼 메모리를 할당하고 해제하는 메모리 할당을 동적 메모리 할당을 할 수 있다. 또한 힙은 Mbyte 단위가 아닌 2Gbyte까지 할당할 수 있기 때문에 메모리를 할당할 때 크기 문제가 거의 발생하지 않는다. 하지만 동적 메모리 할당, 해제를 직접 관리해야 하며, 메모리 크기가 작을 경우 할당하면 힙에 메모리 주소를 저장하기 위한 포인터 변수를 스택에 4byte 크기로 할당하기 때문에 비효율적일 수 있다.

<br><br>

**동적 메모리 할당하기**

malloc() 함수는 void * 형식으로 주소를 반환해야 하는데, void *는 사용할 때마다 형 변환을 해야 하는 불편함이 있기 때문에 malloc()을 사용하여 포인터에 주소를 할당하는 시점에 미리 형 변환을 사용하는 것이 좋다.

- 헤더파일
    - stdlib.h
    - malloc.h
- 함수원형 : void * malloc([size_t](http://en.cppreference.com/w/c/types/size_t) size);

ex) int *ptr = (int *)malloc(32);

ex) short *ptr = (short *)malloc(16);

<br><br>

**동적 메모리 해제하기**

malloc()을 이용해 동적 할당한 포인터 변수는 free() 함수로 동적 메모리를 해제해야 한다. 

왜냐하면 동적 메모리는 지역 함수이기 때문에 함수와 종료 시 동적 할당된 메모리의 주소 값을 알 수 있는 방법이 없어서 해당 메모리가 누실되기 때문이다. 또한 할당되지 않은 메모리를 해제하거나, 정적 할당 메모리를 해제하는 경우에도 실행할 때 오류가 발생한다.

- 함수원형 : void free(void* ptr);

<br><br>

**예제1) 동적 메모리 할당하기**

```c
#include <stdio.h>
#include <malloc.h>
 
int main()
{
    int * ptr = nullptr;
    int limit, count, sum = 0;
 
    scanf_s("%d", &limit);
    ptr = (int *)malloc(sizeof(int) * limit); 
 
    while (count < limit)
    {
        scanf_s("%d", ptr + count );
        count ++;
    }
    
    for (int i = 0; i < count ; ++i)
    {
        if (i > 0)
            printf(" + ");
        printf(" %d ", *(ptr + i)); 
        sum = sum + *(ptr + i);
    }
    
    printf(" = %d\n", sum );
    
    free(ptr); //동적 메모리 해제
    
    return 0;
```

<br><br>

**2차원 포인터 동적 메모리 할당하기**
 
2차원 포인터도 마찬가지로 동적 메모리 할당하는 자료형은 최종 대상의 자료형이기 때문에, sizeof으로 포인터형을 할당할 경우 자료형의 크기에 상관없이 4바이트(포인터 주소 크기)가 할당되고, 1차원 포인터로 할당할 수 있게 된다. 마찬가지로 1차원 포인터로 접근하여 최종 대상도 동적 할당할 수 있다. 

다차원 포인터로 동적 할당한 메모리를 해제할 경우 차원이 큰 순서부터 해제하게 되면 그 보다 작은 차원은 해제하지 못하고 주소 값을 잃어버리게 되므로, 동적 할당한 포인터의 차원이 작은 순서부터 차례대로 해제해야 한다.

- *자료형* ** *변수이름* = (*자료형* **)malloc(sizeof(*자료형* *));

<br><br>

**예제2) 2차원 포인터로 동적 메모리 할당하기**

```c
#include <stdio.h>
#include <malloc.h>
 
int main()
{
    short ** pp = (short**)malloc(sizeof(short*)); //4byte 크기의 1차원 포인터로 동적 메모리 할당
    *pp = (short*)malloc(sizeof(short)); //2byte 크기의 동적 메모리 할당
    
    **pp = 10;
    printf("**pp : %d\n", **pp );
    
    free(*pp); //두번째 동적 메모리 해제
    free(pp); //첫번째 동적 메모리 해제
    
    return 0;
}
```

<br><br>

>[!note]
> **여러 개의 동적 메모리 할당하기**
> 
> malloc()에 할당할 메모리의 전체 크기를 적어도 되지만 sizeof 연산자를 사용하여 메모리의 자료형 단위를 적어서 의도를 좀 더 쉽게 파악할 수 있다. 동적으로 할당한 배열에 접근하는 방법은 포인터 주소 연산을 하여 포인터 변수에 저장되어 있는 주소로 접근할 수 있다.
> 
> 2차원 포인터도 마찬가지로 여러 개의 1차원 포인터를 동적 할당할 수 있으며, 마찬가지로 동적 할당한 1차원 포인터를 여러 개의 대상으로 동적 할당할 수 있다. 이렇게 포인터를 배열 형식으로 동적 할당하게 되면 메모리의 크기를 변경하더라도 다시 컴파일하지 않아도 된다.
> 
> - 1차원 포인터 동적 할당하기 : *자료형* * *변수이름* = (*자료형* *)malloc(sizeof(*자료형*) * *자료형개수*);
> - 2차원 포인터 동적 할당하기 : *자료형* ** *변수이름* = (*자료형* **)malloc(sizeof(*자료형* *) * *자료형개수*);
> 
> ex) int *ptr = (int *)malloc(sizeof(int) * 3);
> 
> *ptr = 1;
> 
> *(ptr + 1) = 2; 
> 
> ptr[2] = 3; 

<br><br>

>[!note]
> **함수의 매개변수와 포인터**
> 
> 함수의 매개변수로 포인터를 사용하는 경우 차원을 잘못 적용할 경우 오류가 발생할 수 있다. 함수의 매개변수가 인자로 포인터를 대입할 경우 하위 차원을 맞춰서 사용하는데 주의한다. 
> 
> **예제3) 매개변수에 포인터 변수를 잘못 사용한 경우**
> 
> ```c
> #include <stdio.h>
> #include <malloc.h>
> 
> void GetPtr(int *_p) //②_p는 같은 1차원 포인터이기 때문에 p의 쓰레기 주소값을 갖게 된다.
> {
>     _p= (int*)malloc(8); //③_p는 쓰레기 주소 값으로 동적 할당했을 뿐 p는 동적 할당을 하지 못한다.
> }
>  
> int main()
> {
>     int *p; //①초기화를 하지 않으므로 쓰레기 값을 보유한다.
>     GetPtr(&p);
>     *p = 5; //④p는 동적 할당을 받지 못하고 쓰레기 주소 값에 5를 저장하기 때문에 오류가 발생한다.
>     free(p);
>     return 0;
> }
> ```
> 
> **예제4) 함수의 매개변수로 2차원 포인터 사용하기**
> 
> ```c
> #include <stdio.h>
> #include <malloc.h>
> 
> void GetPtr(int **_p) //②2차원 포인터 _p에 1차원 포인터 p의 주소 값을 저장한다.
> {
>     *_p= (int*)malloc(sizeof(int)); //③동적 할당된 메모리 주소 값을_p이 가리키는 p에 저장한다.
> }
>  
> int main()
> {
>     int *p;
>     GetPtr(&p); //①1차원 포인터 p의 주소 값을 매개변수로 전달한다.
>     *p= 5; //④동적 할당한 메모리에 5를 저장한다.
>     printf("%d\n", *p);
>     free(p); //⑤GetPtr()에서 메모리를 해제하면 주소 값을 잃어버려 p가 사용할 수 없게 되기 때문에 main()에서 해제한다.
>     return 0;
> }
> ```
