# [C] 표준 라이브러리 : 파일 입출력

<br><br>

## **바이너리 형식과 문자열 형식**

프로그램이 사용하는 데이터 형식은 크게 바이너리 형식, 문자열 형식 두 가지로 나눌 수 있다. 데이터에 다른 의미를 부여하지 않고 숫자 그 자체로 보는 바이너리(Binary)속성과 숫자를 아스키코드 값으로 변환해서 사용하는 문자열(String, Text)속성이다. 결국 이 두 형식은 데이터는 같아도 데이터 속성에 따라 데이터를 사용하는 기준이 서로 다르기 때문에 처리 방법과 결과에 차이가 있으므로 데이터 형식에 따라 사용하는 함수가 다르다.

<br><br>

ex) 데이터를 읽을 때 차이점

- char str[8] = {'a', 'b', 'c', 0, };
- 바이너리 형식
    - str의 데이터를 97, 98, 99, 0, 0, 0, 0, 0 값이 저장되어 있으며,  8byte 크기로 해석한다.
- 문자열 형식
    - str의 데이터를 아스키 값으로 처리하여 0(null 문자)이 나올 때까지 찾아서 "abc" 값이 저장되어 있으며, 3byte 크기로 해석한다.

<br><br>

ex) 데이터 크기를 구할때 차이점

- char str[8] = {'a', 'b', 'c', 0, };
- 바이너리 형식
    - int size = sizeof(str); //sizeof 연산자를 사용하여 메모리의 크기를 구할 수 있다.
- 문자열 형식
    - int length = strlen(str); //strlen()를 사용하여 문자열 길이를 구할 수 있다.

<br><br>

ex) 데이터를 복사할 때 차이점

- char src[8] = {'a', 'b', 'c', 0, };
    
    char dest[8];
    
- 바이너리 형식
    - memcpy(dest, src, sizeof(src)); //memcpy()를 사용하여 변수 값을 그대로 복사한다.
- 문자열 형식
    - strcpy(dest, src); //strcpy()를 사용하여 문자열로 복사하한다. strcpy()는 문자 하나를 복사할 때마다 0을 검사하여 문자열이 끝났는지 제대로 된 문자인지를 검사한다.

<br><br>
<br><br>

## **바이너리 파일과 텍스트 파일**

바이너리 파일은 해당 파일을 사용할 수 있는 프로그램이 설치되어 있어야 하는 반면, 텍스트 파일은 아스키 값으로 구성되어있기 때문에 특별한 프로그램이 설치되어 있지 않아도 텍스트 파일에 적힌 문자열을 확인할 수 있다.

ex) 바이너리 파일과 텍스트 파일

- 바이너리 파일 : 이미지 파일, 음악 파일, 동영상 파일, 실행 파일
- 텍스트 파일 : 문서 파일, 소스 파일

<br><br>
<br><br>

## 파일 입출력 함수

<br><br>

**파일 열기**

프로그램의 작업 경로에서 파일을 찾아서 연다. 파일 열기에 성공하면 FILE * 형식의 메모리 주소 값을 반환하고, 파일 열기에 실패하면 null 값을 반환한다. fopen()에 사용할 파일 이름은 문자열로 저장해야 하며, 사용할 파일이 현재 작업 경로에 없다면 전체 경로로 표기해야 한다.

- 헤더 파일 : stdio.h
- 함수 원형 : FILE *fopen( const char *filename, const char *mode );

```c
FILE *pFile = fopen("test.dat","r");
if(NULL != pFile)
{
	//파일 열기에 성공
}
else
{
	//파일 열기에 실패
}
```

<br><br>

>[!note]
> **FILE 구조체**
> 
> FILE 구조체는 디스크에 있는 파일의 형태, 파일의 데이터를 저장, 읽는 방법 등의 정보를 저장하고 있는 구조체이다. 표준 입출력 라이브러리는 FILE 구조체로 선언한 포인터 변수를 파일 포인터라고 하며, 파일 입출력 함수를 호출할 때마다 파일 포인터를 넘겨주도록 되어 있다. FILE 구조체를 사용하지 않더라도 C언어의 표준 입출력 라이브러리에서 제공하는 파일 입출력 함수들을 사용하면 구조체의 요소들을 직접 관리할 수 있다. 그러나 파일 처리에 관련된 정보를 몰라도 파일 포인터만 넘겨주면 파일 입출력 함수가 알아서 처리하도록 만들어져 있어, 파일을 좀 더 편하게 사용할 수 있다.
> 
>  하지만 FILE구조체를 사용하는 표준 입출력 함수가 주기억 장치에 비해 속도가 느린 보조기억 장치의 단점을 보완한다. 그리고 표준 입출력 함수의 내부에서 이루어지는 것이라서 함수들이 사용하는 FILE구조체의 요소들을 모두 이해할 필요는 없다.
> 
> - FILE 구조체의 요소
>     
>     ```c
>     struct _Iobuf
>     {
>     	char *_ptr;
>     	char *_base;
>     	int _file;
>     	int _bufsiz;
>     }; typedef struct _iobuf FILE;
>     ```
    
<br><br>

>[!note]
> **파일 사용 형식**
> 
> 파일을 사용할 때 파일 사용 형식을 지정할 수 있다.
> 
> - b : 바이너리 형식으로 파일을 사용한다. 기본값이기 때문에 형식을 지정할 때 t 또는 b를 포함하 고 있지 않다면 기본적으로 b 형식을 사용한다.
> - t : 텍스트 형식으로 파일을 사용한다. 만약 t 형식으로 바이너리 파일을 열면 파일 열기는 성공하지만, 파일 입출력 함수를 사용하면 오류가 발생하는데, 바이너리 파일은 파일의 실제 크기를 사용하고 텍스트 파일은 아스키 값을 사용해 0 값으로 파일의 끝을 찾아 크기를 결정하기 때이다.
> - r : 파일을 읽기 형식으로 파일을 연다. 파일이 열었는데 파일이 없으면 파일 열기에 실패하고 null을 반환한다. 바이너리 파일은 rb로, 텍스트 파일은 rt로 사용할 수 있다.
>     
>     ex) FILE *pFile = fopen("binary.dat","rb");
>     
>     FILE *pFile = fopen("text.txt","rt");
>     
> - w : 파일 쓰기 형식으로 파일을 연다. 만약 파일이 없다면 파일을 생성한 후에 파일을 연다. 그러나 같은 이름의 파일이 이미 존재하는 경우에는 파일을 열고 데이터를 모두 지우고 시작하기 때문에 주의해야 한다. 그리고 디스크 용량이 부족하거나 읽기 전용 디스크일 경우 파일 열기에 실패한다. 바이너리 파일은 wb로, 텍스트 파일은 wt로 사용할 수 있다.
> - a : 파일 이어 쓰기 형식으로 파일을 연다. 만약 파일이 작업 경로에 없다면 파일을 생성한 후에 파일을 연다. 그리고 파일이 존재하더라도 파일 데이터를 지우지 않고 이어 쓰기를 한다. 이 형식도 디스크에 용량이 부족하거나 읽기 전용 디스크에 사용하면 파일 읽기에 실패한다. 바이너리 파일은 ab로, 텍스트 파일은 at로 사용할 수 있다.
> - r+ : 파일 읽기와 쓰기를 같이 사용할 때 읽기를 강조하여 파일을 연다. 이 형식으로 파일을 여는 경우 기존 파일이 없으면 파일 읽기에 실패한다. 기존 파일이 있는 경우에는 데이터를 지우지 않지만 기존 데이터의 위치로 이동에서 해당 위치의 내용을 덮어쓸 수 있다. 바이너리 파일은 rb+로, 텍스트 파일은 rt+로 사용할 수 있다.
> - w+ : 읽기와 쓰기를 같이 사용할 때 쓰기를 더 강조하여 파일을이다. 이 형식으로 파일을 여는 경우 기존 파일이 없으면 파일을 새로 만들고, 기존 파일이 있는 경우 내용을 모두 지우고 시작한다. 바이너리 파일은 wb+로, 텍스트 파일은 wt+로 사용할 수도 있다.
> - a+ : 읽기와 이어 쓰기를 같이 사용할 때 이어쓰기를 강조하여 파일을 연다. 기존 파일이 없으면 파일을 새로 만들고, 기존 파일이 존재하면 파일의 기존 내용에 이어서 시작한다는 뜻이다. 하지만 r+와 달리 기존 데이터 위치로 이동할 수 있고 읽기도 가능하지만 쓰기를 사용하면 현재 위치와 상관없이 파일의 끝에 내용이 추가된다. 바이너리 파일은 ab+로, 텍스트 파일은 at+로 사용할 수도 있다.

<br><br>
<br><br>

**파일 닫기**

파일 사용이 끝나면 fclose() 함수를 사용하여 파일을 닫아야 한다. 만약 파일을 열어 놓고 파일을 닫지 않으면 파일의 내용이 지워지거나 파일을 사용할 수 없는 상태가 될 수 있으니 주의한다. 그리고 파일을 열지 않은 상태에서 파일 닫기를 시도하거나 이미 닫은 FILE * 주소로 파일 닫기를 다시 시도하면 오류가 발생할 수 있다.

- 함수 원형 : int fclose( FILE *stream );

```c
FILE *pFile = fopen("binary.dat", "r+b");
if(NULL != pFile)
{
	//파일 열기에 성공
	fclose(pFile);
}
else
{
	//파일 열기에 실패
}
```

<br><br>

>[!note]
> **파일 데이터의 읽을 위치 지정하기**
> 
> 원하는데 데이터의 원하는 위치에서 읽을 수 있다.offset 매개변수에는 이동 거리, origin 매개 변수에는 기준 위치를 작성한다.
> 
> - 함수 원형 : int fseek( FILE *stream, long offset, int origin );
> 
> ex) fseek(pFile, 32, SEEK_CUR); //현재 위치에서 32byte만큼 뒤로 이동

<br><br>

>[!note]
> **파일 데이터의  읽을 위치 확인하기**
> 
> 현재 열려 있는 파일의 데이터를 읽거나 저장할 위치를 확인한다.
> 
> - 함수 원형 : long ftell( FILE *stream );

<br><br>
<br><br>

**텍스트 파일에 데이터 읽고 쓰기**

- 함수 원형 : int fprintf( FILE * stream, const char *format, ... );

<br><br>

**예제1) 텍스트 파일에 문자열 저장하기**

```c
#include <stdio.h>
 
int main()
{
    FILE *pFile;
    errno_t err;
 
    err = fopen_s(&pFile, "d:\\success.txt", "wt");
    if (NULL != pFile)
    {
        fprintf(pFile, "please success\n");
        fclose(pFile);
        printf("성공\n");
    }
    else
    {
        printf("실패\n");
    }
    
    return 0;
}
```

![https://blog.kakaocdn.net/dn/djax2b/btqxCOBN31X/FeIX7ENoARFQaboRlrKYek/img.png](https://blog.kakaocdn.net/dn/djax2b/btqxCOBN31X/FeIX7ENoARFQaboRlrKYek/img.png)

<br><br>

>[!note]
> **바이너리 형식를 문자열 형식으로 저장하기**
> 
> 변수의 바이너리 데이터를 텍스트 파일에 저장하려면 서식 지정자 키워드를 사용해서 문자열 형식으로 변환해야 한다. fprintf()는 호출될 때마다 파일에 저장한 문자열의 개수만큼 파일 포인터를 이동시키므로, 연속적으로 fprintf()를 호출하면 문자열이 차례대로 저장된다.
> 
> ex) short int nData = 0x0412;
> 
> fprintf(pFile,%x\n",nData); //파일에 "412"라고 저장한 후 줄 바꿈.
> 
> ex) short int nData = 0x0412;
> 
> fprintf(pFile,"Hello\n");
> 
> fprintf(pFile,"%x\n",nData);

<br><br>
<br><br>

**텍스트 파일에서 데이터 읽기**

fscanf()는 소스 파일과 같은 경로에 있어야 정상적으로 수행되기 때문에 파일 경로에 주의한다. 또한 기본적으로 공백 문자를 입력하면 다음 입력이 시작된 것으로 처리되므로 문자열 사이에 공백이 있으면 한 줄 단위로 출력하지 못하고 단어 단위로 화면에 출력하게 된다. 따라서 텍스트 파일에서 한 줄 단위로 문자열을 처리해야 하는 경우 fgets()를 사용한다.

- 함수 원형 : int fscanf(FILE * stream, const char *format [,argument]...);

<br><br>
<br><br>

**바이너리 파일에 데이터 읽고 쓰기**

문자열 형식은 문자열에 포함된 0을 찾아서 데이터 크기를 검사하기 때문에 문자열 길이를 추가로 작성할 필요가 없다. 하지만 바이너리 형식은 데이터를 그냥 숫자로만 판단하기 때문에 표준 입출력 함수가 길이나 크기를 알아낼 수 없으므로, 바이너리 형식으로 데이터를 읽고 쓰려면 반드시 직접 크기를 작성해야 한다.

<br><br>
<br><br>

**바이너리 파일에 데이터 저장하기**

fwrite() 함수는 저장할 데이터의 시작 주소부터 데이터의 자료형 크기로 자료형 개수만큼 파일에 데이터를 쓰게 되므로, 실제로 파일에 저장되는 크기는 자료형 크기 × 자료형 개수이다. 자료형 개수의 용도는 배열을 파일에 저장할 때 size 매개변수에는 자료형 크기, count 매개변수에는 배열의 개수를 작성한다. 그런데 저장할 크기를 자료형 크기와 반복 횟수로 나누는 것은 배열 요소에 의미를 더 부여하기 위한 것이고, 자료형 크기에 배열 크기나, 배열 이름을 기입할 수도 있다. 주의할 점은 fwrite()는 디스크 용량이나 파일 속성(쓰기 제한) 때문에 파일 저장하기를 실패할 수 있으므로, 반환값을 검사해서 파일에 데이터가 제대로 저장되었는지 확인해야 한다. fwrite()가 저장에 성공하면 자료형 개수를 반환하기 때문에 이 값을 검사하자.

- 함수 원형 : size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );
- 사용 방법 : fwrite(*데이터의시작주소*, *데이터의자료형크기*, *반복횟수*, *파일포인터*);

ex) int n = 0x00000412;

fwrite(&n, sizeof(int), 1, pFile);

//n이 할당된 메모리를 4byte 크기만큼 1회만 pFile 포인터가 가리키는 바이너리 파일에 저장한다.

<br><br>

ex) fwrite()를 사용하여 배열의 데이터를 파일에 저장하기

int arData[5] = {0, 1, 2, 3, 4};

fwrite(arData,sizeof(int),5 pFile);

//(= fwrite(arData,sizeof(int) * 5, 1, pFile);)

//(= fwrite(arData,sizeof(arData),1,pFile);)

<br><br>
<br><br>

**바이너리 파일에서 데이터 읽기**

fread()를 이용해 배열로 선언한 변수에 값을 저장할 때 두 번째 매개변수에는 자료형을 작성하고 세 번째 매개변수에는 배열 요소의 개수를 의미하는 반복값을 기입한다. fread()도 마찬가지로 단위 크기를 배열 크기나,배열 이름으로도 기입할 수 있다.

디스크 섹터에 문제가 발생하거나 실제 파일에 있는 데이터보다 더 많이 읽으라고 명령할 경우 작업에 실패할 수 있다. 따라서 fread() 함수의 반환값을 체크해 파일에서 데이터를 제대로 읽어 왔는지 확인하는 게 좋다. 성공하면 실제로 반복한 횟수만큼 반환하기 때문에 값을 확인하여 오류를 처리한다.

- 함수 원형 : size_t fread( void *buffer, size_t size, size_t count, FILE * stream );
- 사용 방법 : fread(*읽은데이터를저장할주소*, *저장할데이터의기준단위크기*, *반복횟수*, *파일포인터*);

ex) fread(&nData,sizeof(int),1,pFile);

int arData[5];
