# [C] 포인터(pointer)

텍스트: 깃허브 업로드 하였으나 내용 수정 필요

# 운영체제의 메모리 관리 방식

<aside>
💡 **32비트 운영 체제와 64비트 운영체제의 메모리 관리**

64비트 운영체제가 지원되면서 운영체제에 실행되는 프로그램도 32비트 프로그램과 64비트 프로그램으로 나누어 개발할 수 있으며, 32비트 운영체제는 메모리를 4GB(2^30)밖에 사용하지 못하고, 64비트 운영체제는 16EB(2^60)까지 사용할 수 있어 시스템이 메모리를 4GB 이상 사용한다면 64bit 운영 체제를 설치해야 한다. 또한 동시처리능력, 메모리 확장성에서 반드시 64비트를 사용해야 하는 경우도 있다. 그러나 64bit 운영 체제는 데이터의 기본 처리 단위가 64비트이기 때문에 메모리 사용량이 많으며 32비트 프로그램과 호환하려면 실행 모듈까지 관리해야 하기 때문에 낮은 사양의 컴퓨터에 64비트 운영 체제를 설치하는 것은 오히려 손해이며, 32bit 방식으로 개발해도 32bit 운영 체제와 64bit 운영 체제에 모두 동작하기 때문에 특별한 경우가 아니면 32비트 프로그램을 개발하는 경우가 많다. C언어의 int형(4byte)이 32비트 운영체제의 비트 수와 일치한다.

</aside>

### 직접 주소 지정 방식

사용할 메모리 주소를 직접 적지 않아도 변수로 메모리를 사용할 수 있다. 그러나 지역 변수는 해당 함수 안에서만 사용이 가능하기 때문에 서로 다른 함수에 존재하는 변수를 참조할 수없어 함수의 매개 변수, 반환 값만 이용하여 서로 다른 함수의 지역 변수의 값을 주고 받을 수 있다.

### 간접 주소 지정 방식

직접 주소 지정 방식의 한계를 해결하기 위해 포인터 변수를 이용해 메모리 주소를 사용하고 수정할 수 있다.

---

# 포인터(pointer)

포인터 키워드(*)를 이용해 포인터 변수를 만들고 다른 변수의 메모리 주소를 저장하여 사용할 수 있다.

### **포인터 변수 선언하기**

자료형은 포인터가 가리키는 대상의 자료형으로 해야하고, 포인터 변수는 32비트 운영체제 기준으로 메모리 주소는 4byte이다.

메모리 주소는 프로그램이 실행될 때마다 주소가 달라지므로 포인터가 가리키는 대상의 주소를 직접 입력해서 항상 같은 주소를 사용하게 되면 대부분 오류가 발생하므로 프로그램 안에 선언한 다른 변수의 주소를 받아와서 사용하면 변수는 해당 프로그램의 메모리 영역에 만들어져 안전하다. 포인터 변수는 가리킬 대상의 시작 주소를 기억한다. 

- 포인터 변수 초기화하기 : *자료형* **변수이름* = nullptr;
- 포인터 변수에 일반 변수 참조하기 : *자료형* **변수이름* = &*일반변수*;
- 포인터 변수에 포인터 변수 참조하기 : *자료형* **변수이름* = *포인터변수*;
- 포인터 변수에 배열 참조하기
    
    배열은 배열의 첫번째 요소가 배열 전체의 시작 주소이므로, 포인터 변수에 배열의 시작 주소를 저장할 수 있다. 이때 배열의 자체가 시작 주소이기 때문에 &를 사용하지 않고도 배열의 주소를 저장할 수도 있다.
    
    - *자료형 변수이름* = &*배열변수*[0];
    - *자료형 변수이름* = *배열변수*;
    
    ex) char arr[3] = {};
    
    ex) char *ptr = arData;
    

<aside>
💡 **포인터 배열에 변수 참조하기**

포인터 변수도 배열로 선언하여 사용할 수 있다.

- 1차원 배열
    - *자료형* **변수이름*[*요소개수*] = nullptr;
    
    ex) 포인터 여러 개를 1차원 배열로 선언하고 사용하기
    
    ```c
    #include <stdio.h>
     
    int main()
    {
    		int *p_arr[3] = nullptr; //포인터 자료형의 크기인 4바이트가 총 3개이므로 12byte의 크기가 선언된다.
    		int a, b, c = 0;
    		pData[0] = &a;
    		pData[1] = &b;
    		pData[2] = &c;
    		*pData[0] = 1; //a = 1;
    		*pData[1] = 2; //b = 2;
    		*(pData + 2) = 3; //c =3;
    
    		return 0;
    }
    ```
    
- 2차원 배열
    - *자료형* (**변수이름*)[*1차원배열의요소개수*] = nullptr;
    
    ex) 포인터 여러 개를 2차원 배열로 선언하고 사용하기
    
    ```c
    #include <stdio.h>
     
    int main()
    {
        char arr[4][4] = {};
        char(*ptr)[4] = nullptr;
        ptr= arr; //포인터 변수는 2차원 배열의 시작주소를 저장하게 된다.
     
        (*ptr)[1] = 3;      //arr[0][1] = 3;
        (*(ptr+ 1))[2] = 4; //arr[1][2] = 4;
        ptr[2][4] = 5;      //arr[2][4] = 5;
    
    		return 0;
    }
    ```
    
</aside>

<aside>
💡 **void * 형 포인터**

포인터 변수가 가리키는 대상의 크기가 정해져 있지 않다면 void 키워드를 사용해야 한다. 포인터 변수에 주소 값을 저장할 수는 있지만 해당 주소의 값을 저장할 크기는 정해져 있지 않으므로 시작 주소는 알고 끝 주소는 모를 때 사용하는 포인터 형식이다. void * 형 포인터를 일반 포인터처럼 사용하면 오류가 발생하기 때문에 void*는 반드시 형 변환 문법을 사용하여 '사용할 크기'를 결정하여 일반 포인터처럼 사용할 수 있다.

- void * 형 포인터의 활용
    - void * 형 포인터 변수는 형 변환으로 모두 저장할 수 있기 때문에 사용할 대상의 크기 지정을 잠시 미룰 수있다.
    - 자료형이 사용할 때마다 달라질 경우 지역 변수의 주소 값을 매개 변수로 받아서 어떤 형식의 주소이든 저장할수 있다. 그러나 어떤 형식을 사용했는지 알 수 없기 때문에 형식을 의미하는 값을 매개 변수로 함께 전달해야 한다.
</aside>

<aside>
💡 **const 키워드 사용 방법**

- *자료형* const **변수*;
    
    : 포인터의 대상을 변경할 수 없다.
    
- const *자료형* **변수*;
    
    : 포인터의 대상의 값을 변경할 수 없다.
    
- const *자료형* const **변수*;
    
    : 포인터의 대상과 대상의 값을 변경할 수 없다.
    
</aside>

### **포인터 변수 사용하기**

포인터 변수를 선언하는 포인터 키워드(* )가 아닌, 주소 지정 연산자(* )를 사용하면 포인터의 대상의 주소를 참조하여 값을 사용할 수 있다.

- 포인터의 대상이 일반 변수일 경우
    - **포인터변수* = *값*;
- 포인터의 대상이 배열일 경우
    
    포인터는 대상의 시작 주소를 저장하고 있기 때문에 포인터의 주소 연산을 하여 다른 메모리 주소로 이동할 수 있다.
    
    - *(*포인터변수* + *인덱스*) = *값*;
    - *포인터변수*[*인덱스*] = *값*;
    
    ex) 포인터 변수 선언하고 사용하기
    
    ```c
    #include <stdio.h>
     
    int main()
    {
        int arr[3] = {};
    		int *ptr = arr;
    		*ptr = 10; //arr[0] 참조
    		*(ptr + 1) = 20; //arr[1] 참조
    		ptr[2] = 30; //arr[2] 참조
    
    		return 0;
    }
    ```
    

<aside>
💡 **포인터와 대상의 크기가 다를 경우 포인터 주소 연산**

포인터 주소 연산을 이용하여 크기가 큰 자료형을 작은 자료형 단위로 사용할 수 있다.

ex) 포인터 크기가 작은 자료형으로 사용하기

```c
#include <stdio.h>
 
int main()
{
    int nData = 0x12345678;
    char * pData = (char *)&nData;
 
    for (int i = 0; i < 4; i++)
    {
        printf("%X,", *(pData+i)); //int형 주소를 char*형으로 형 변환하여 시작 주소부터 1byte 크기만 출력한다.
    }
 
    return 0;
}
```

</aside>

<aside>
💡 **배열의 한계를 이용한 포인터 연산**

배열은 포인터가 아니라 일반 변수들을 묶어 놓은 개념이기 때문에 시작 주소를 변경할 수는 없다.

int형 배열의 요소의 값을 1byte 단위로 끊어서 값을 변경하고 싶을 경우 요소의 자료형의 크기가 이미 int형으로 정해져 있기 때문에 값이 변경되면 4byte 크기만큼 값 전체가 변경된다. 이러한 배열의 한계를 해결하기 위해 배열 표기법([]) 대신 포인터 표기법(*)을 사용하면 형 변환 문법을 사용하여 바이트 단위로 나누어서 값을 변경할 수 있다.

ex) 배열로 값을 바이트 단위로 변경할 경우

int arData[2] = {0x12345678, 0x12345678};

arData[0] = 0x22; //arData[0] : 0x00000022

ex) 포인터 연산으로 값을 바이트 단위로 변경할 경우

int arData[2] = {0x12345678, 0x12345678};

int *pData = arData;

(char*)(pData+1) = 0x22; //arData[1] : 0x12345622;

</aside>

<aside>
💡 **다른 함수에 선언된 지역 변수 사용하기**

- 직접 주소 지정 방식을 이용하여 매개변수로 다른 함수의 변수 값 받기
    
    다른 함수의 변수의 값을 복사해서 사용할 수 있다.
    
    ex) 다른 함수에 선언된 지역변수 값 받기
    
    ![https://blog.kakaocdn.net/dn/c2s3uh/btqxBQlQ8yl/xGiuZkmfmaKG468GGboFn1/img.png](https://blog.kakaocdn.net/dn/c2s3uh/btqxBQlQ8yl/xGiuZkmfmaKG468GGboFn1/img.png)
    
- 간접 주소 지정 방식을 이용하여 매개변수로 다른 함수의 변수 주소 받기
    
    다른 함수의 변수의 주소를 참조하기 때문에 사용하고 변경할 수도 있다.
    
    ex) 다른 함수의 선언된 지역변수의 주소 받기
    
    ![https://blog.kakaocdn.net/dn/IjaT3/btqxDVzwtaq/Kd3f6ghkeBNIrUXtbZQ7c0/img.png](https://blog.kakaocdn.net/dn/IjaT3/btqxDVzwtaq/Kd3f6ghkeBNIrUXtbZQ7c0/img.png)
    
- 함수의 return문으로 결과 값 반환하기
    
    다른 함수로 결과값을 반환할 수 있다.
    
</aside>

---

# 다차원 포인터

다차원 포인터는 포인터 키워드(*)를 여러개 붙인 포인터 변수를 선언하면, * 한개 당 자신의 한 단계 아래의 하위 차원의 포인터를 저장한다.

이러한 다차원 포인터는 최대 7차원까지 사용할 수 있다.

### **2차원 포인터의 선언하기**

2차원 포인터는 포인터 키워드(*)를 두 개 사용해 선언하여 자신의 하위 차원인 1차원 포인터를 저장할 수 있다. 

2차원 포인터에 주소를 대입하여 초기화하지 않을 경우 nullptr 키워드로 초기화할 수있다.

- 2차원 포인터 초기화하기 : *자료형* ** 포인터변수 = nullptr;

ex) 2차원 포인터에 하위 차원 대입하기

int n = 1; //일반 변수

int *p = &n; //1차원 포인터에 일반변수 주소 대입

int **pp = &p; //2차원 포인터에 1차원 포인터 주소 대입

### **2차원 포인터 사용하기**

다차원 포인터 선언 후 하위 차원에 접근할 때는 주소지정 연산자(*)개수만큼 이동하여 사용할 수 있다.

2차원 포인터를 사용할 때는 최대 2개의 주소(1차원 포인터, 일반 변수)까지 접근이 가능하다.

ex) 2차원 포인터 선언하고 사용하기

```c
#include <stdio.h>
 
int main()
{
    short n = 3; //일반변수
    short *p = &n; //1차원 포인터변수에 일반 변수 주소 대입
    short **pp = &p; //2차원 포인터변수에 1차원 포인터변수 주소 대입
 
    printf("%d\n", n); //3
    
    *p = 4; //1차원 포인터변수인 *p에는 일반변수인 n의 주소가 저장되어 있으므로 n의 값이 4로 변경된다.
    printf("%d\n", n); //4
    
    **pp = 5; //마찬가지로 2차원 포인터 변수인 **pp에는 *p 주소가 저장되어 있고, *p 주소에는 n의 주소가 저장되어 있으므로 n의 값이 5로 변경된다.
    printf("%d\n", n); //5
    
    return 0;
}
```

<aside>
💡 **다차원 포인터 사용 시 주의점**

1.  하위 차원이 맞지 않는 포인터를 저장할 경우

& 연산자가 반환하는 포인터의 차원이 맞지 않기 때문에 같은 차원으로 형 변환을 하여 저장해야 한다.

ex) 2차원 포인터에 일반 변수 저장하기

short n = 3;
short **pp = (short**) &n; 

//&n이 반환하는 주소의 자료형은 short*형이기 때문에 short**형인 **pp에 주소를 저장할 수 없게 된다.

//그러므로 2차원 포인터 변수와 자료형을 맞추기 위해 short**형으로 형 변환해야 한다.

1. 자신과 같은 차원의 포인터를 저장할 경우

마찬가지로 포인터의 차원이 맞지 않기 때문에 같은 차원으로 형 변환을 하여 저장해야 하며, 하위 포인터를 사용할 수 없기 때문에 효율성이 떨어진다.

ex) 2차원 포인터에 2차원 포인터 저장하기

short **pp1 = 3;
short **pp2 = (short**) &pp1;

//&pp1이 반환하는 주소의 자료형은 short*** 형이기 때문에 short** 형으로 형 변환해야 하며, **pp2는 사용하지 않아도 되는 변수가 된다.

</aside>