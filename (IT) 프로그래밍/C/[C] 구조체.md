# [C] 구조체

<br><br>

# 구조체

각각 다른 자료형을 그룹으로 묶어서 새로운 자료형을 만들 수 있다.

```c
struct *구조체이름*
{
	*자료형*1 *변수이름*1;
	*자료형*2 *변수이름*2;
	*자료형*3 *변수이름*3;
	.....
};
```

<br><br>
<br><br>

### **구조체 선언하기**

구조체도 배열과 마찬가지로 데이터를 묶는 형태이기 때문에 { }를 사용하여 요소의 초깃값을 대입하면 된다. 이때, 구조체에 정의한 요소의 순서와 초깃값의 순서가 같아야 한다.

- *구조체 변수이름*;
- *구조체 변수이름* = {*요소1의값*, *요소2의값*, …);

<br><br>
<br><br>

### **구조체 사용하기**

구조체의 변수는 . 요소 지정 연산자를 사용하여 접근할 수 있다. 또한 포인터에 접근하려면 * 주소 지정 연산자를 사용해서 변수의 주소로 이동한 다음 . 연산자를 사용해야 하는데, * 연산자가 . 연산자보다 우선선위가 낮아서 * 에 ()괄호를 사용해야 한다. 이렇게 포인터 변수는 접근이 불편하기 때문에 ->연산자를 제공하여 연산자 우선순위 문제를 해결할 수 있도록 한다.

- 일반 변수의 요소 사용하기 : *변수이름*.*요소*;
- 배열의 요소 사용하기 : *변수이름*[*인덱스*].*요소*;
- 포인터의 요소 사용하기 : *변수이름*->*요소*;

<br><br>

**예제1) 구조체 선언하고 사용하기**

```c
#include <stdio>

struct People
{
	char name[12]; //12byte
	unsigned short int age; //2byte
	float height; //4byte
	floar weight; //4byte
	//총 22byte
};

void main()
{
	People people;
	People.age = 28;
	People.height = 124.8;

	People peoples[64];
	
	People *p;
	p = &people;
	p->age = 24; //(*p).age = 24;
}
```
<br><br>

>[!note]
> **구조체 크기 최적화하기**
>
> 구조체는 다양한 크기의 자료형을 하나의 그룹으로 묶어서 사용하다 보니 구조체 요소를 사용할 때 실행 속도가 떨어지는 문제가 있다. 그래서 C 컴파일러는 구조체의 요소를 일정한 크기로 정렬하여 실행 속도를 더 빠르게 할 수 있도록 구조체 멤버 정렬을 제공하는데, 1,2,4,8 바이트 기준으로 정렬할 수 있다. 구조체 자료형의 크기는 구조체를 구성하는 요소들의 크기를 모두 더한 것과 같지 않고, 실제로 컴파일러에서 구조체 정렬 기준을 어떻게 설정하는지에 따라 구조체의 크기가 달라질 수 있기 때문에 단순히 구조체의 모든 요소의 크기를 더해서 구조체 크기로 사용하면 버그가 발생할 수도 있으므로 동적 메모리 할당을 할 때는  sizeof 연산자를 사용하여 자료형의 크기를 구해야 안전하다. 결론적으로 자료형의 크기는 구조체 자료형을 선언할 때 같은 크기의 요소들끼리 모아 주는 것만으로도 프로그램의 효율을 크게 높일 수 있다. 이처럼 작은 부분이라도 소스 코드를 구성하면 특별한 최적화 작업을 해주지 않아도 메모리 사용 효율을 높일 수 있다.
> 
> - 1바이트 정렬
> 
> 이 정렬을 사용하면 구조체의 본래 의미대로 메모리가 구성된다.
> 따라서 이 기준으로 정렬된 자료형의 크기는 구조체를 구성하는 요소들의 크기를 합산한 것과 같다.
> 
> - 2바이트 정렬
> 
> 각 요소는 2의 배수에서 해당하는 주소에서 시작할 수 있고 전체 크기가 2의 배수가 되어야 한다.
> 따라서 요소가 놓일 주소가 2의 배수가 아니라면 해당 1바이트를 버리고 2의 배수가 되는 주소에 놓인다.
> 하지만 예외적으로 요소의 자료형이 2바이트보다 작은 경우의 1바이트는 그대로 1바이트로 정렬된다.
> 
> ex) 2byte 정렬
> 
> ```c
> typedef struct Test
> {
> 	char a; //1byte → 2byte
> 	int b; //4byte
> 	short c; //2byte
> 	char d; //1byte
> };
> 
> //2바이트 정렬 기준을 적용하면 9byte가 되지만 2바이트 정렬은 전체 크기가 2의 배수가 되어야하기 때문에 10바이트가 된다. 
> //그리고 마지막 1바이트를 사용하지 않아 버리게 된다.
> ```
> 
> - 4바이트 정렬
> 
> 각요소는 4의 배수에 해당하는 주소에서 시작할 수 있고 전체 크기가 4의 배수가 되어야 한다.
> 따라서 요소가 놓일 주소가 4의 배수가 아니라면 해당 1~3바이트를 버리고 4의 배수가 되는 주소에 놓인다.
> 하지만 요소의 자료형이 4바이트보다 작은 경우에는 해당 요소의 크기로 정렬된다.
> 
> ex) 4byte 정렬
> 
> ```c
> typedef struct Test
> {
> 	char a; //1byte → 4byte
> 	int b; //4byte → 4byte
> 	short c; //2byte → 2byte
> 	char d; //1byte → 2byte
> };
> 
> //전체 크기는 11byte가 되어야 하지만  4바이트 정렬 기준을 적용하면 전체 크기가 4의 배수가 되어야 하기 때문에 12byte가 된다. 
> //그리고 마지막 1byte를 사용하지 않는다.
> ```
> 
> - 8바이트 정렬
> 
> 구조체를 정렬할 때 모든 요소가 기준 정렬 바이트보다 작으면 요소 중에서 가장 큰 요소의 크기로 정렬된다.
> 각 요소는 8의 배수에 해당하는 주소에서 시작할 수 있고 전체 크기가 8의 배수가 되어야 한다.
> 따라서 요소가 놓일 주소가 8의 배수가 아니라면 해당 1~7바이트를 버리고 8의 배수가 되는 주소에 놓인다.
> 하지만 요소의 자료형이 8바이트보다 작은 경우에는 해당 요소의 크기로 정렬이된다.
> 
> ex) 8byte 정렬
> 
> ```c
> typedef struct Test
> {
> 	char a; //1byte → 8byte
> 	double b; //8byte
> 	short c; //2byte
> 	char d; //1byte → 8byte
> };
> 
> //결국 8바이트 정렬을 기준으로 하면 전체 크기가 19byte가 되어야 하지만 8바이트 정렬은 전체 크기가 8의 배수가 되어야 하기 때문에 크기는 24byte가 된다.
> //그리고 마지막 5byte를 사용하지 않는다.
> //이 구조체는 24byte 중에서 무려 12byte나 버려진다.
> //그런데 요즘 컴파일러들은 8바이트 정렬을 기본 값으로 하고 있기 때문에 구조체에 8byte 크기의 자료형을 사용하지 않았다면 낭비가 적겠지만 double이나 __int64 같은 8byte크기의 자료형을 사v용하면 구조체의 크기가 갑자기 커지게 될 것이다.
> ```

<br><br>

**예제2) 구조체 크기 최적화하기**

```c
//기존 구조체
typedef struct Test
{
	char a; //1byte→ 8byte
	double b; //8byte
	short c; //2byte
	char d; //1byte
};

//개선된 구조체
typedef struct Test
{
	char a; //1byte
	char d; //1byte
	short c; //2byte
	double b; //8byte
};

//단순히 구조체의 요소의 순서만 변경 했을 뿐인데 구조체의 전체 크기가 16byte가 되고 낭비되던 메모리가 12byte 에서 4byte 로 줄어들었다.
//8의 배수 안에 주소(1,2,4바이트 정렬로 나란히)가 모두 안착되기 때문이다.
```
