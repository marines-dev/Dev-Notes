# [C] 연산자

<br><br>

## **대입 연산자**

= 연산자는 변수에 상수, 변수 값을 대입할 수 있다.

ex) int a = 5;

int b = a;

<br><br>
<br><br>

## **산술 연산자**

+, -, *, /, % 연산자는 상수, 변수 값을 이용하여 산술 연산을 한다.

<br><br>
<br><br>

## **증감 연산자**

++ 증가 연산자는 변수 값을 1 증가시키고, -- 감소 연산자는 1 감소한다.

이때, 전위형은 증감 연산자를 변수 앞에 사용하여 먼저 증감을 한 후에 연산을 하고, 후위형은 변수 뒤에 사용하여 연산을 한 후에 증감한다.

<br><br>
<br><br>

## **관계 연산자**

<, >, <=, >=, ==, != 연산자의 결과 값은 진릿값으로 거짓이면 0, 참이면 1이다.

<br><br>
<br><br>

## **논리 연산자**

&&(AND), ||(OR), !(NOT) 연산자의 결과 값은 진릿값으로 거짓이면 0, 참이면 1이다.

<br><br>
<br><br>

## **시프트 연산자**

시프트 연산에는 <<(overflow), >>(underflow) 가 있다. 오버플로는 변수의 값을 지정한 비트 수만큼 왼쪽으로 이동하여 $2^{n}$을 곱한 것과 같고, 언더플로는 오른쪽으로 이동하여 $2^{n}$을 나눈 것과 같은데, 변수에서 이동한 비트 메모리 공간의 크기를 벗어나면서 해당 비트들은 사리지고 빈자리는 0으로 채워진다. 주의할 점은 시프트 연산자는 연산자우선순위가 낮아 다른 연산자와 함께 사용할 경우 괄호를 이용해야 한다.곱셈, 나눗셈 연산자는 속도가 느린 반면 시프트 연산자는 더 빠르다. 

<br><br>
<br><br>

## **비트 연산자**

&(AND), |(OR), ^(XOR), ~(NOT) 연산자는비트 단위로 연산할 수 있다.

<br><br>

>[!note]
> **비트 연산자 활용 방법**
>
> - 보수를 이용하여 덧셈 연산으로 뺄셈 연산하기
> 
>   자료형의 크기보다 더 큰 값이 들어오면 오버플로(<<)가 발생하여 벗어난만큼 값을 잃어버리게 된다. 그러므로 ~(NOT) 연산자로 비트를 반전시켜 1의 보수 후에, 1의 보수에 1을 더하여 2의 보수한 값을 더하면 뺄셈 연산을 수행할 수 있다. 컴퓨터에는 뺄셈 회로가 없기 때문에 보수를 사용하여 연산하는데, 직접 비트 연산자를 이용해 보수로 뺄셈 연산을 하면 뺄셈 회로를 하나 줄일 수 있다.
> 
>   ex) 보수를 이용하여 0 구하기
>   
>   ```c
>   unsigned char a =198;// unsigned char 범위 : 255
>   
>   unsigned char b = ~a; //57
>   
>   ++b; //58
>   
>   a += b; // 198 + 58 = 256 -> 0
>   ```
> 
> - 8비트 암호화
>
>   데이터에 암호화 데이터를 ^(XOR) 연산하면 전혀 새로운 값이 나오고 다시 ^ 연산하면하면 처음 값으로 되돌아오기 때문에 간단하게 데이터를 암호화할 수 있다. 데이터를 파일에 저장, 네트워크 전송 등을 할 때 ^ 연산을 사용하여 간단하게 암호화하면 보안성이 좋아진다. 보안성을 더 높이고 싶다면 암호화에 사용하는 비트 개수를 더 늘리면 된다.
    
</aside>
