# [프로그래밍] 연산자

## **단항 연산**

<aside>

NOT, Shift, Move, Rotate, Complement, Move AB

</aside>

## **이항 연산**

<aside>

AND, OR, XOR, 사칙연산

</aside>

## **수치적 연산**

사칙 연산, 산술 Shift

> **💡 산술 Shift**
> 
> - 왼쪽 Shift : 왼쪽으로 1비트를 이동할 경우 저장된 값에 2를 곱한 것과 같으며, 곱셈에서 사용된다. Shift 한 결과가 원래 데이터가 저장된 장소의 크기보다 커지면 Overflow 현상이 발생한다.
> - 오른쪽 Shift : 오른쪽으로 1비트를 이동할 경우 저장된 값을 2로 같으며, 나눗셈에 사용된다. 오른쪽으로 밀려 나가는 값이 유효 비트일 경우에는 Truncation 현상이 발생한다.

**예제1) 11001010을 왼쪽으로 Shift 2번 수행**

<aside>

11001010 → 00101000

</aside>

**예제2) 11001010을 오른쪽으로 Shift 3번 수행**

<aside>

11001010 → 0001001

</aside>

### **비수치적 연산**

AND, OR, NOT, 논리 Shift, Rotate, Move 등

> 비수치적 연산
> 
> - AND : 이항 연산으로, 두 값이 모두 1이면 1이다. 데이터의 일부를 삭제할 경우 사용한다.
> - OR : 이항 연산으로, 두 값 중 하나라도 1이면 1이다. 데이터의 일부를 추가할 경우 사용한다.
> - XOR : 이항 연산으로, 두 값이 다르면 1이고, 같으면 0이다. 데이터를 암호화할 때 사용한다.
> - NOT : 단항 연산으로, 값을 반전시켜서 보수를 취한다. 비트가 0이면 1이고, 1이면 0이다.

**예제1) 00111100과 00001111의 AND 연산**

<aside>

00111100 & 00001111 = 00001100

</aside>

**예제2) 00111100과 00001111의 OR 연산**

<aside>

00111100 | 00001111 = 00111111

</aside>

**예제3) 00111100과 00001111의 XOR 연산**

<aside>

00111100 ^ 00001111 = 00110011

</aside>

**예제4) 00001111의 NOT 연산**

<aside>

~ 00001111 = 11110000

</aside>

### **보수**

컴퓨터에는 뺄셈 회로가 없기 때문에 보수를 취하여 덧셈 연산을 하면 뺄셈 연산을 수행할 수 있다.

N + N‘ = r일 때 N’를 N에 대한 r의 보수라고 하는데, r진법에는 r의 보수와 r-1의 보수가 존재한다.

10진법에는 10의 보수와 9의 보수가, 2진법에는 2의 보수와 1의 보수가 있다.

**r의 보수**

N의 자릿수 개수만큼 0을 채우고 가장 왼쪽에 1을 추가한 값을 만들고, N 뺀다.

> **보수 구하기 TIP**
> 
> - 1의 보수 : 주어진 각 자리값을 0일 때는 1로, 1일 때는 0으로 변환한다. ex) 11001 → 00110
> - 2의 보수 : 1의 보수를 구한 뒤 결과 값에 1을 더한다. ex) 11001 → 00110 + 1 → 00111

**r-1의 보수**

- 진수 N에 대한 9의 보수는 N의 자릿수만큼 9를 채우고, N을 뺀다.
- 2진수 N에 대한 1의 보수는 N의 자릿수만큼 1을 채우고, N의 각 자릿수를 뺀다.

**예제1) 33에 9의 보수**

<aside>

33 → 99

99 = 33 = 66

</aside>

**예제2) 10110에 1의 보수**

<aside>

10110 → 11111

11111 - 10110 = 01001

</aside>