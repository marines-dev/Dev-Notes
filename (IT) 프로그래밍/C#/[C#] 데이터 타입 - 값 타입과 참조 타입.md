# [C#] 데이터 타입 : 값 타입과 참조 타입

<br><br>

# **데이터 타입(Data Type)**

C, C++은 기본 데이터가 메모리와 직결되고 메모리 크기만큼만 저장된다면, C#을 포함한 닷넷 프로그래밍 언어는 [**.**](http://msdn.microsoft.com/ko-kr/library/2hf02550(v=VS.90).aspx)NET의 Common Type System에 정의된 닷넷 데이터 타입을 사용하며, C# 컴파일러는 C#의 데이터 타입을 컴파일 후 닷넷 데이터 타입으로 변경한다. C#의 데이터 타입은 크게 값 타입과 참조 타입이 있다.

<br><br>

### **값 타입**(Value Type)

값 타입의 메모리는 스택을 사용하여 값을 저장하는 독립적인 값으로, 변수에 값을 할당하면 선언과 동시에 바로 쓸 수 있고, 값 타입의 파라미터 전달은 데이터를 복사한다.
System.Object와 System.ValueType에 정의되어 있는 값 타입은 모두 구조체로 만들기 때문에 상속될 수 없으며, 주로 간단한 데이터 값을 저장하는데 사용한다. 값 타입 종류는 구조체, 기본 데이터형(정수, 실수, 문자), 열거형이 있다.

ex) 값 타입의 구조

```jsx
// System.Int32 (Value Type)
public struct Int32 
{ 
   //....
}
```

<br><br>

>[!note]
> **값 타입의 종류**
> 
> - 정수 : byte, short, int, long
> - 실수(부동 소수점) : flaot, double
> - 고정밀 10진수 부동 소수점 : decimal
> - 문자 : char
> - bool : true/false
> - 열거형 : enum
> - 구조체 : struct

<br><br>
<br><br>

### **참조 타입**(Reference Type)

참조 타입의 메모리는 힙을 사용하며 new 연산자를 이용해 생성할 수 있고, new로 생성하지 않은 변수는 참조 형태로 사용된다. 참조 타입의 파라미터 전달은 원본 객체에 대한 참조가 된다. 

System.Object에 정의되어 있는 참조 타입은 클래스로 만들기 때문에 상속이 가능하고, 주로 복잡한 데이터와 기능을 정의할 때 사용한다. 구현에 있어 어떤 Type을 선택하는가는 해당 Type의 특성을 고려해서 결정해야 하는 문제이다. 참조 타입 종류로는 배열, 문자열, 클래스, 인터페이스, 델리게이트가 있다.

ex) 참조 타입의 구조

```csharp
// System.String (Reference Type)
public sealed class String 
{
   //....
}
```

<br><br>

>[!note]
> **가비지 컬렉터**
> 
> 닷넷의 C#은 가비지 컬렉터는 참조되지 않는 메모리를 자동으로 수거하는 메모리 수거 장치로, 참조 타입으로 데이터 선언 후 new 연산자로 할당 시 가비지 컬렉터의 메모리 관리가 들어간다.

<br><br>

>[!note]
> **깊은 복사와 얕은 복사**
> 
> 값 형식과 참조 형식의 결정적인 차이점은 객체의 대입이 일어날 때 뚜렷해진다.
> 값 형식에서 사용되는 구조체는 인스턴스가 가진 메모리가 복사되어 새로운 변수에 대입되는 데, 이를 다른 말로 깊은 복사라고 한다.  예를 들어, v1의 값을 v2에 대입하면 메모리 상에서 깊은 복사가 일어나고 v2는 새로운 인스턴스를 가리키기 때문에 v2의 값을 바꿔도 그 변화가 v1과 전혀 무관하게 이루어진다.
> 이러한 구조체의 장점은 힙 메모리의 사용을 줄여 성능을 최적화할 수 있다.
> 반면 참조 형식의 객체가 대입되는 방식을 일컬어 얕은 복사라고 한다. 예를 들어,  p1과 p2는 같은 메모리 상의 인스턴스를 가리키고 있으므로 둘 중 어느 하나라도 해당 필드의 값을 변경하면 변수의 결괏값이 함께 변경된다.

<br><br>

>[!note]
> **ref와 out 예약어**
> 
> 값 형식과 참조 형식의 동작 방식에 공통점은 변수의 스택 값은 여전히 복사된다는 점이다.
> 값 형식의 변수는 해당 변수가 실제 값을 가리키고 있고, 따라서 그 값이 복사되어 전달된다. 반면 참조 형식 변수는 힙에 존재하는 실제 데이터의 주솟값을 가리키고 있으며 따라서 그 주솟값이 복사되어 전달된다.
> 이렇게 "변수의 스택 값"이 복사되는 상황을 특별히 메서드 인자 전달과 관련해 값에 의한 호출(Call by value, CBV)이라 한다.
> 이와 구분해서 참조에 의한 호출(Call by reference, CBR)라는 방법도 있다. 이 방식으로 메서드에 인자를 전달하면 변수의 스택 값이 복사되는 것이 아니라 해당 변수의 스택 값을 담고 있는 주소 자체가 전달된다. C#에서는 "참조에 의한 호출"을 지원하기 위해 두 가지 예약어를 추가했는데 , ref와 out이다. 
> 
> C#에서 ref와 out은 메서드에 인수로 전달된 변수의 참조를 통해 값을 읽거나 변경할 수 있도록 하는 키워드이다. 둘 다 변수의 메모리 참조를 전달하지만, 사용 방식과 의도에는 차이가 있다.
> 
> - ref **:** 메서드가 변수의 값을 읽거나 수정할 수 있도록 참조로 전달한다. 메서드에 전달하기 전에 변수가 초기화되어 있어야 하며, 호출된 메서드가 값을 변경하지 않아도 된다.
> - out : 메서드가 반환값 이외에 추가적인 값을 반환할 수 있도록 설계되었다. 메서드에 전달하기 전에 변수를 초기화하지 않아도 되며, 메서드 내부에서 반드시 해당 변수를 초기화해야 합니다.

<br><br>

**예제1) ref와 out 차이점**

```csharp
using System;

class Program
{
    // ref를 사용하여 값을 읽고 수정
    static void ModifyWithRef(ref int number)
    {
        number += 10; // number 값 증가
    }

    // out을 사용하여 값을 반환
    static void InitializeWithOut(out int number)
    {
        number = 20; // 반드시 초기화
    }

    static void Main()
    {
        // ref 예제
        int valueRef = 5; // 초기화 필요
        Console.WriteLine("Before ref: " + valueRef);
        ModifyWithRef(ref valueRef); // ref로 전달
        Console.WriteLine("After ref: " + valueRef);

        // out 예제
        int valueOut; // 초기화 필요 없음
        InitializeWithOut(out valueOut); // out으로 전달
        Console.WriteLine("After out: " + valueOut);
    }
}
```
